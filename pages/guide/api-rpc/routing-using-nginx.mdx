import Link from 'next/link'

# Routing using NGINX

## Prerequisites

You will need NGINX installed and your Node running before you continue with this.

For NGINX, it is already covered in <Link href="/guide/api-rpc/server-preperation">Server Preparation</Link>

For Nodes, you can look for the guides in <Link href="/testnet">Testnet section</Link>

## Create per subdomain NGINX config

In this section, we will use <Link href="/pages/testnet/airchain">Airchain</Link> as our reference project

## API

Creating Your NGINX Configuration File

The first step involves creating a new configuration file specific to your subdomain. This file will dictate how NGINX handles incoming requests to your API. Use the following command to create a new configuration file for your project's API subdomain:

```js copy
sudo nano /etc/nginx/sites-available/airchains-api-testnet
```

This command opens up a text editor within your terminal. If you prefer a different text editor, feel free to substitute nano with your editor of choice, such as vim or gedit.

### Configuring NGINX for Your API Subdomain

With the file open, it's time to input the necessary configuration for your API subdomain. Below is a template specifically designed for a Node.js application. Make sure you understand each directive and modify it to suit your application's specific needs, especially the proxy_pass directive, which should point to your application's running port:

```js copy
server {
    listen 80;
    server_name airchains-api-testnet.zulnaaa.com;

    location / {
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Max-Age 3600;
        add_header Access-Control-Expose-Headers Content-Length;
        
        proxy_pass http://127.0.0.1:1317;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

This configuration sets up your server to listen on port 80, which is the default port for HTTP. The server_name should match your project's subdomain. The proxy_pass directive is crucial as it tells NGINX where to forward requests that hit this subdomain. In this example, it's set to the localhost on port 1317, which is the default port for many Node.js applications.

## RPC

### Creating Your NGINX Configuration File

Just like configuring the API subdomain, setting up an RPC subdomain requires a similar approach but points to a different server application port. This setup is crucial for applications that interact with your server using the Remote Procedure Call (RPC) protocol. Below is a tailored NGINX configuration for an RPC server setup. Remember to modify the proxy_pass directive to match your RPC server's listening port:

```js copy
sudo nano /etc/nginx/sites-available/airchains-rpc-testnet
```

### Configuring NGINX for Your RPC Subdomain

```js copy
server {
    listen 80;
    server_name airchains-rpc-testnet.zulnaaa.com;
    
    location / {
        proxy_pass http://127.0.0.1:26657;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

## Activating Your Configuration

After tailoring the configuration file to your needs and saving your changes, the next step is linking this file to the sites-enabled directory to activate it:

sudo ln -s /etc/nginx/sites-available/airchains-*-testnet /etc/nginx/sites-enabled/

This command creates a symbolic link between the sites-available and sites-enabled directories, effectively enabling your configuration.

Finally, test the NGINX configuration for syntax errors:

```js copy
sudo nginx -t
```

If the test passes without issues, reload NGINX to apply the changes:

```js copy
sudo systemctl reload nginx
```

Your subdomains are now set up and should be accessible via the specified subdomain. This setup enhances your project's structure by clearly distinguishing between different parts of your application, making it easier for developers and users to interact with your endpoints application, making it easier for developers and users to interact with your endpoints.

But, all of your endpoints still using HTTP which is not secure. We will setup SSL for all of our endpoint in the next section